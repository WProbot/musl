My Developer Notes

Differences from traditional BASICs:
====================================

PRINT is a function call, not a statement (mostly because if used as an embedded scripting language there may not be anywhere to print to).

Comments use hash symbols rather than single quotes. This is partly because I wanted single quotes to have the same meaning as double quotes, as in Javacript.

REM is not supported for comments.

Statements found in some old BASICs that are not available include CLS, LOCATE, WHILE-WEND and so on.

There aren't any arrays, only hash tables, and they are indexed using [] instead of ().

DIM is not needed (and not implemented) because of the way these hash tables are implemented.

'&' is the string concatenation operator.
'~' is the not-equals operator.

DATA is also a function, rather than a statement.

The operator @ operator is for /references/. The expression @identifier converts the identifier to a string, so @ARRAY$ will be equivalent to "ARRAY$". 

It is useful, because functions like DATA() and MAP() takes as a first parameter the name of the variable as a string. Using the @ operatior makes it clear that the parameter is a reference to a variable.

Things I would like to change (when I find time):
=================================================

The () around function parameters should be optional:
    PRINT "Hello World"
should be equivalent to
	PRINT("Hello World")
even if I only implement it at the statement level.

mu_error_text() can be improved to search for the begining of the line where the error occurred. Then the current column can be obtained by subtracting the beginning of the line from the current m->s pointer. This can give you a much better indication of what the error is.

Array indexes are case sensitive: people["John Doe"] and people["john doe"] refer to two separate variables, even though all other variables are case insensitive: Person and person will refer to the same variable. Do I change the case sensitivity of array indexes?
* Case for Yes: It is more consistent with the rest of the language. It also means I can later implement something like vector.x to mean the same as vector["x"] and remain consistent with the rest of the language in terms of case sensitivity.
* Case for No: When you put "John Doe" into people[], you probably really meant "John Doe", not "john doe".

I really ought to run Musl through Valgrind again at some point.

I should also compile it with Regex support again to make sure I haven't broken anything.

I really ought to rename mu_set_num() and mu_get_num() to mu_set_int() and mu_get_int().

ToDo Built-In Functions:
========================

Ideas for built-in functions that may be useful go in this section.

Replace$(str$, find, repl) - Replaces occurances of 'find' with 'repl' in str

GSUB$() - Like Awk's gsub() function (instead of replace$() above)

Speaking of Awk, how about a function AWK(line$, [delim$]) that takes line$ and splits it into columns in the _C[i], so that a Musl script can do some of the same work as Awk. It returns the number of columns found in the line. _C["length"] should be the same as the arrays filled in by DATA() 

Actually, the above is just a SPLIT() function. I would actually like to have functions like ColdFusion's List functions. They are very much in the spirit of Musl.

ASC() and CHR() for converting between characters and numbers: ASC('A') is 65 and CHR(65) is 'A'

How about an Oracle-like DECODE() function (see http://www.techonthenet.com/oracle/functions/decode.php for details)?

I'd also like to have a feature to dump all the variables somewhere for debugging Musl programs. It should be an API function and a Built-in function.
